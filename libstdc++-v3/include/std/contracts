// Contracts support header for -*- C++ -*-

// Copyright (C) 2019-2024 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file contracts
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_CONTRACTS
#define _GLIBCXX_CONTRACTS 1

#pragma GCC system_header

#include <source_location>
#include <cstdint>
#include <exception> // std::terminate, std::exception_ptr
#include <new> // for nothrow_t.
#include <cxxabi.h>

#ifdef __cpp_contracts

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

namespace contracts
{
  // From P2900R14 + D3290R3
  enum class assertion_kind : uint16_t {
    pre = 1,
    post = 2,
    assert = 3,
    manual = 4, // From D3290R3
    cassert = 5, // From D3290R3

    /* Implementation−defined values should have a minimum value of 1000. */
  };

  enum class evaluation_semantic : uint16_t {
    ignore = 1,
    observe = 2,
    enforce = 3,
    quick_enforce = 4,

    /* FIXME: Implementation−defined values should have a minimum value of 1000
      but we cannot [currently] accommodate > 7.
      Experimental only (no paper).  */
    noexcept_enforce = 5,
    noexcept_observe = 6,
    force_quick = 7,
  };

  enum class detection_mode : uint16_t {
    unspecified = 0,  // From D3290R3
    predicate_false = 1,
    evaluation_exception = 2,

    /* To be extended with implementation−defined values and by future extensions
       Implementation−defined values should have a minimum value of 1000. */
  };

  using __vendor_ext = void;

  class contract_violation {
#if __cpp_contracts >= 202502L

    __builtin_contract_violation_type __impl;

  public:
    const auto version () const noexcept {
      return __builtin_contract_data (this, 0);
    }
    const assertion_kind kind () const noexcept {
      return __builtin_contract_data (this, 1);
    }
    const evaluation_semantic semantic() const noexcept {
      return __builtin_contract_data (this, 2);
    }
    const detection_mode mode () const noexcept {
      return __builtin_contract_data (this, 3);
    }
    const char* comment () const noexcept {
      return __builtin_contract_data (this, 4);
    }
    const std::source_location location () const noexcept {
      return __builtin_contract_data (this, 5);
    }

    std::exception_ptr
    evaluation_exception () const noexcept {
      if (mode () == std::contracts::detection_mode::evaluation_exception)
	return std::exception_ptr (__builtin_contract_data (this, 6));
      return std::exception_ptr ();
    }
    __vendor_ext *ext() const noexcept {
      return __builtin_contract_data (this, 7);
    }

    bool is_terminating () const noexcept {
      return semantic () == evaluation_semantic::enforce
	    || semantic () == evaluation_semantic::quick_enforce;
    }
#else
    uint16_t _M_version;
    assertion_kind _M_assertion_kind;
    evaluation_semantic _M_evaluation_semantic;
    detection_mode _M_detection_mode;
    const char* _M_comment;
    std::source_location _M_source_location;
    void *_M_current_except_obj;
    __vendor_ext* _M_ext;

  public:
    // cannot be copied, moved or assigned to
    contract_violation(const contract_violation&) = delete;
    contract_violation& operator=(const contract_violation&) = delete;

    const uint16_t version()  const noexcept { return _M_version; }
    assertion_kind kind() const noexcept { return _M_assertion_kind; }
    evaluation_semantic semantic() const noexcept { return _M_evaluation_semantic; }
    detection_mode mode() const noexcept { return _M_detection_mode; }
    const char* comment() const noexcept { return _M_comment; }
    std::source_location location() const noexcept { return _M_source_location; }
    std::exception_ptr
    evaluation_exception () const noexcept
     {
      if (_M_detection_mode == std::contracts::detection_mode::evaluation_exception)
        return std::exception_ptr (_M_current_except_obj);
      return std::exception_ptr ();
    }
    __vendor_ext *ext() const noexcept { return _M_ext; }

    bool is_terminating () const noexcept {
      return _M_evaluation_semantic == std::contracts::evaluation_semantic::enforce
	    || _M_evaluation_semantic == std::contracts::evaluation_semantic::quick_enforce;
    }
#endif
  };

  void invoke_default_contract_violation_handler(const contract_violation&) noexcept;

  // From D3290R3

  [[noreturn]]
  inline void
  handle_enforced_contract_violation(
      const char*msg,
      const std::source_location &__location = std::source_location::current())
    { __builtin_contract_violation_with
	(msg, __location,
	 std::contracts::evaluation_semantic::enforce,
	 std::contracts::assertion_kind::manual);
    }

  [[noreturn]]
  inline void
  handle_enforced_contract_violation(
      const std::nothrow_t&,
      const char*msg,
      const std::source_location &__location = std::source_location::current()) noexcept
    { __builtin_contract_violation_with
	(msg, __location,
	 std::contracts::evaluation_semantic::enforce,
	 std::contracts::assertion_kind::manual);
    }


  inline void
  handle_observed_contract_violation(
      const char *msg,
      const std::source_location &__location = std::source_location::current())
    { __builtin_contract_violation_with
	(msg, __location,
	 std::contracts::evaluation_semantic::observe,
	 std::contracts::assertion_kind::manual);
    }

  inline void
  handle_observed_contract_violation(
      const std::nothrow_t&,
      const char *msg,
      const std::source_location &__location = std::source_location::current()) noexcept
    { __builtin_contract_violation_with
	(msg, __location,
	 std::contracts::evaluation_semantic::observe,
	 std::contracts::assertion_kind::manual);
    }

  [[noreturn]]
  inline void
  handle_quick_enforced_contract_violation(
      const char*,
      const std::source_location &__location = std::source_location::current()) noexcept
  { std::terminate (); }

} // namespace contracts

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // __cpp_contracts

#endif // _GLIBCXX_CONTRACTS
